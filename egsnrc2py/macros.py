import re
from typing import Tuple
from pprint import pprint
from textwrap import dedent
from egsnrc2py._util import nested_brace_value, fix_identifiers
from egsnrc2py.config import (
    default_float, AUTO_TRANSPILE_PATH, MORTRAN_SOURCE_PATH,
    INTEGER, REAL, LOGICAL
)


def test_eval_subst(code):
    pattern = r"\$EVALUATE (\w*) USING (\w*)\((\w*)\);?"
    subst = """
    [IF] '\g<2>'=SNAME1
    [\g<1>=\g<2>1(L\g<3>)*\g<3>+\g<2>0(L\g<3>);] [ELSE]
    [\g<1>=\g<2>1(L\g<3>,MEDIUM)*\g<3>+\g<2>0(L\g<3>,MEDIUM);]}
    """
    # subst = r"\1"
    # m = re.search(pattern, code)
    # print(m.groups())

    code = re.sub(pattern, subst, code, re.MULTILINE)
    return code


def find_all_macros_used(code):
    """Return all identifiers starting with $ in the code"""
    pattern = r" *?(\$[\w-]+)" #r"^ *?(\$[-\w]*)"
    matches = re.findall(pattern, code)
    return set(matches)


def find_macros_including_macros(code):
    """Matches where the WITH replace also has $ in it"""
    # pattern = r"REPLACE\s*?\{\s*?(\$[\w-]*);?\}\s*?WITH\s*?\{(.*\$.*);?\}"
    # matches = [m for m in re.finditer(pattern, code, flags=re.MULTILINE)]
    # return [m.groups() for m in matches]

    return {
        k:v for k,v in find_all_replaces(code).items()
        if '$' in v
    }


def find_all_replaces(code):
    pattern = r"REPLACE\s*?\{(.*)\}\s*?WITH\s*?\{(.*)\}"
    return dict(m.groups() for m in re.finditer(pattern, code))


def escape(s) -> str:
    """To clean up the "from side" for regex searching"""
    return re.escape(s)
    # for c in ["$", "[", "+"]:
    #     s = s.replace(c, r"\c")
    # return s


def macro_types(all_from_to) -> Tuple[list, list, list, list]:
    """Scan through code to check if macros are ever assigned, or called

    Returns
    -------
        (constant, callable, defined_block, other)
        All list of tuples (from, to)

    Note: search with r"\$\w*?\s*?=" in full egsnrc.mortran
       found no assigned <$var =>'s, except in string printouts,
       so if not called, then are constant


    """
    called = []
    constant = []
    defined_block = []
    other = []

    for m_from, m_to in all_from_to.items():
        # See if called - if alone on a line (except comments):
        if m_from.startswith(("$COMIN", ";COMIN", "$DEFINE", "$DECLARE")):
            defined_block.append((m_from, m_to))
            continue
        macro_str = escape(m_from)
        alone_pattern = rf'^ *{macro_str}\s*?(["#].*?$)?;?'
        if re.search(alone_pattern, code, flags=re.MULTILINE):
            called.append((m_from, m_to))
        # See if has a open bracket right after it
        # pattern = rf"\W{macro}\s*?\("
        # if re.search(pattern, code, flags=re.MULTILINE):
        #     called.append(macro)
        else:
            if get_type(m_to) is None:
                other.append((m_from, m_to))
            else:
                constant.append((m_from, m_to))

    return constant, called, defined_block, other


def generate_macros_py(filename:str, code: str) -> None:
    """Generate py code with info used by the transpile code

    e.g. lists of macros that are const vs callables
    code should be full egsnrc.mortran to capture full information
    """
    constant_macros, called_macros, defined_block_macros = macro_types(code)

    with open(filename, 'w') as f:
        f.write("# autogenerated by _util.generate_macros_py")
        for name, _list in [
            ("constant_macros", constant_macros),
            ("called_macros", called_macros),
            ("defined_blocks_macros", defined_block_macros)
        ]:
            f.write("\n\n")
            f.write(f"{name} = [\n")
            f.write(
                "".join(f"    '{name}',\n" for name in sorted(_list))
            )
            f.write("]")


def map_replace_from_to(code: str) -> str:
    """Goes through the .macros `code` and determines all REPLACE .. WITH"""
    all_from_to = {}
    pattern = r"^ *REPLACE\s*\{(.*)\}\s*?WITH\s*?\{"
    i = 0
    subcode = code  # need to update search string to exclude REPLACE in val
    while True:
        match = re.search(pattern, subcode, flags=re.MULTILINE)
        if not match:
            break
        replace_from = match.group(1)
        replace_to = nested_brace_value(subcode, match.end())
        all_from_to[replace_from] = replace_to
        # print(replace_from, " -> ", replace_to)
        i += len(match.group(0)) + len(replace_to) + 1  # one extra for }
        subcode = code[i:]

    return all_from_to


def get_type(m_to):
    try:
        int(m_to)
        return INTEGER
    except ValueError:
        try:
            float(m_to)
            return REAL
        except ValueError:
            if m_to in [".false.", ".true."]:
                return LOGICAL
    return None


def modified_macros(egsnrc_code, egsnrc_macros) -> None:
    """Return egsnrc.macros with our custom (partial) replacements

    The custom one will be handed to modified EGSnrc compile_user_script
    to generate the macros we don't want to deal with.

    Returns
    -------
    macros_code
        The original .macros code modified with some changes
    list[Tuple]
        A list of (varname, type, value) for the output parameters file

    """

    all_from_to = map_replace_from_to(egsnrc_macros)
    constant_macros, called_macros, defined_block_macros, other = macro_types(all_from_to)



    # Go through the macros file, modifying the "REPLACE ... WITH" macro "with"
    # part with the macro name minus the $.  This becomes a named "constant"
    # (really a parameter) in a python parameters file
    # generate sorted list - largest first in case some names are subset of others
    new_macros = egsnrc_macros
    parameters = []
    sorted_from = sorted(all_from_to, key=lambda x: len(x), reverse=True)
    constant_set = set(mac[0] for mac in constant_macros)  # faster lookup than a list
    for m_from in sorted_from:
        m_to = all_from_to[m_from]
        if m_from in constant_set:
            # doubled {{ and }} needed for f-string to give a single
            pattern = rf" *REPLACE\s*?\{{{m_from}\}}\s*?WITH\s*?\{{{m_to}\}}"
            bare_name = m_from.replace("$", "")  # 'from' name without $
            new_macros = re.sub(pattern, bare_name, new_macros)
            _type = get_type(m_to)
            if m_to == ".false.":
                m_to = "False"
            elif m_to == ".true.":
                m_to = "True"
            parameters.append((bare_name, _type, m_to)) # original constant val for params
        # try:
        #     int(m_to)
        #     egsnrc_macros = re.sub()
        # except TypeError:
        #     try:
        #         float(m_to)
        #     except TypeError:
        #         continue
    return new_macros, parameters


def write_new_macros_file(filename, macros_code) -> None:
    with open(filename, "w") as f:
        f.write(egsnrc_macros)

def write_params_file(filename, parameters) -> None:
    with open(filename, "w") as f:
        f.write("import numpy as np\n\n")
        for name, _type, value in sorted(parameters):
            f.write(f"{name}: {_type} = {value}\n")


if __name__ == "__main__":

    in_filename = MORTRAN_SOURCE_PATH / "electr.mortran"
    with open(in_filename, 'r') as f:
        code = f.read()

    with open(MORTRAN_SOURCE_PATH / "egsnrc.macros", 'r') as f:
        egsnrc_macros = f.read()

    egsnrc_macros = fix_identifiers(egsnrc_macros)
    # egsnrc_macros = dedent("""REPLACE {$MAXL_MS}    WITH {63}
    #     REPLACE {$MAXQ_MS}    WITH {7}
    #     REPLACE {$MAXU_MS}    WITH {31}
    #     REPLACE {$0-MAXL_MS}  WITH {0:63}
    #     """
    # )
    with open(MORTRAN_SOURCE_PATH / "egsnrc.mortran", 'r') as f:
        egsnrc_code = f.read()

    filename = AUTO_TRANSPILE_PATH / "egsnrc_mod.macros"
    macros_code, parameters = modified_macros(egsnrc_code, egsnrc_macros)
    write_new_macros_file(filename, macros_code)

    filename = AUTO_TRANSPILE_PATH / "params.py"
    write_params_file(filename, parameters)
